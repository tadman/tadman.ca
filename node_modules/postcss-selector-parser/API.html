<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>API Documentation</title>
    <link rel="stylesheet" media="all" href="/assets/css/main.css"/>
  </head>
  <body class="bg-blue-900 p-8">
    <h1 id="api-documentation">API Documentation</h1>

<p><em>Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.</em></p>

<h2 id="parser-function"><code class="language-plaintext highlighter-rouge">parser</code> function</h2>

<p>This is the module’s main entry point.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">postcss-selector-parser</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="parsertransform-options"><code class="language-plaintext highlighter-rouge">parser([transform], [options])</code></h3>

<p>Creates a new <code class="language-plaintext highlighter-rouge">processor</code> instance</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">processor</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">();</span>
</code></pre></div></div>

<p>Or, with optional transform function</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">transform</span> <span class="o">=</span> <span class="nx">selectors</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">selectors</span><span class="p">.</span><span class="nx">walkUniversals</span><span class="p">(</span><span class="nx">selector</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">selector</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">processor</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">transform</span><span class="p">)</span>

<span class="c1">// Example</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">processSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">*.class</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// =&gt; .class</span>
</code></pre></div></div>

<p><a href="#processor">See processor documentation</a></p>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">transform (function)</code>: Provide a function to work with the parsed AST.</li>
  <li><code class="language-plaintext highlighter-rouge">options (object)</code>: Provide default options for all calls on the returned <code class="language-plaintext highlighter-rouge">Processor</code>.</li>
</ul>

<h3 id="parserattributeprops"><code class="language-plaintext highlighter-rouge">parser.attribute([props])</code></h3>

<p>Creates a new attribute selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">attribute</span><span class="p">({</span><span class="na">attribute</span><span class="p">:</span> <span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; [href]</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parserclassnameprops"><code class="language-plaintext highlighter-rouge">parser.className([props])</code></h3>

<p>Creates a new class selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">className</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; .button</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parsercombinatorprops"><code class="language-plaintext highlighter-rouge">parser.combinator([props])</code></h3>

<p>Creates a new selector combinator.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">combinator</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">+</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; +</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<p>Notes:</p>
<ul>
  <li><strong>Descendant Combinators</strong> The value of descendant combinators created by the
parser always just a single space (<code class="language-plaintext highlighter-rouge">" "</code>). For descendant selectors with no
comments, additional space is now stored in <code class="language-plaintext highlighter-rouge">node.spaces.before</code>. Depending
on the location of comments, additional spaces may be stored in
<code class="language-plaintext highlighter-rouge">node.raws.spaces.before</code>, <code class="language-plaintext highlighter-rouge">node.raws.spaces.after</code>, or <code class="language-plaintext highlighter-rouge">node.raws.value</code>.</li>
  <li><strong>Named Combinators</strong> Although, nonstandard and unlikely to ever become a standard,
named combinators like <code class="language-plaintext highlighter-rouge">/deep/</code> and <code class="language-plaintext highlighter-rouge">/for/</code> are parsed as combinators. The
<code class="language-plaintext highlighter-rouge">node.value</code> is name after being unescaped and normalized as lowercase. The
original value for the combinator name is stored in <code class="language-plaintext highlighter-rouge">node.raws.value</code>.</li>
</ul>

<h3 id="parsercommentprops"><code class="language-plaintext highlighter-rouge">parser.comment([props])</code></h3>

<p>Creates a new comment.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">comment</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/* Affirmative, Dave. I read you. */</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; /* Affirmative, Dave. I read you. */</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parseridprops"><code class="language-plaintext highlighter-rouge">parser.id([props])</code></h3>

<p>Creates a new id selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">id</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">search</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; #search</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parsernestingprops"><code class="language-plaintext highlighter-rouge">parser.nesting([props])</code></h3>

<p>Creates a new nesting selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">nesting</span><span class="p">();</span>
<span class="c1">// =&gt; &amp;</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parserpseudoprops"><code class="language-plaintext highlighter-rouge">parser.pseudo([props])</code></h3>

<p>Creates a new pseudo selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">pseudo</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">::before</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; ::before</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parserrootprops"><code class="language-plaintext highlighter-rouge">parser.root([props])</code></h3>

<p>Creates a new root node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">root</span><span class="p">();</span>
<span class="c1">// =&gt; (empty)</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parserselectorprops"><code class="language-plaintext highlighter-rouge">parser.selector([props])</code></h3>

<p>Creates a new selector node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">selector</span><span class="p">();</span>
<span class="c1">// =&gt; (empty)</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parserstringprops"><code class="language-plaintext highlighter-rouge">parser.string([props])</code></h3>

<p>Creates a new string node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">string</span><span class="p">();</span>
<span class="c1">// =&gt; (empty)</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parsertagprops"><code class="language-plaintext highlighter-rouge">parser.tag([props])</code></h3>

<p>Creates a new tag selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">tag</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">});</span>
<span class="c1">// =&gt; button</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h3 id="parseruniversalprops"><code class="language-plaintext highlighter-rouge">parser.universal([props])</code></h3>

<p>Creates a new universal selector.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">universal</span><span class="p">();</span>
<span class="c1">// =&gt; *</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">props (object)</code>: The new node’s properties.</li>
</ul>

<h2 id="node-types">Node types</h2>

<h3 id="nodetype"><code class="language-plaintext highlighter-rouge">node.type</code></h3>

<p>A string representation of the selector type. It can be one of the following;
<code class="language-plaintext highlighter-rouge">attribute</code>, <code class="language-plaintext highlighter-rouge">class</code>, <code class="language-plaintext highlighter-rouge">combinator</code>, <code class="language-plaintext highlighter-rouge">comment</code>, <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">nesting</code>, <code class="language-plaintext highlighter-rouge">pseudo</code>,
<code class="language-plaintext highlighter-rouge">root</code>, <code class="language-plaintext highlighter-rouge">selector</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">tag</code>, or <code class="language-plaintext highlighter-rouge">universal</code>. Note that for convenience,
these constants are exposed on the main <code class="language-plaintext highlighter-rouge">parser</code> as uppercased keys. So for
example you can get <code class="language-plaintext highlighter-rouge">id</code> by querying <code class="language-plaintext highlighter-rouge">parser.ID</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">parser</span><span class="p">.</span><span class="nx">attribute</span><span class="p">({</span><span class="na">attribute</span><span class="p">:</span> <span class="dl">'</span><span class="s1">href</span><span class="dl">'</span><span class="p">}).</span><span class="nx">type</span><span class="p">;</span>
<span class="c1">// =&gt; 'attribute'</span>
</code></pre></div></div>

<h3 id="nodeparent"><code class="language-plaintext highlighter-rouge">node.parent</code></h3>

<p>Returns the parent node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">root</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">parent</span> <span class="o">===</span> <span class="nx">root</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="nodetostring-stringnode-or---node"><code class="language-plaintext highlighter-rouge">node.toString()</code>, <code class="language-plaintext highlighter-rouge">String(node)</code>, or <code class="language-plaintext highlighter-rouge">'' + node</code></h3>

<p>Returns a string representation of the node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">id</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">search</span><span class="dl">'</span><span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="nx">id</span><span class="p">));</span>
<span class="c1">// =&gt; #search</span>
</code></pre></div></div>

<h3 id="nodenext--nodeprev"><code class="language-plaintext highlighter-rouge">node.next()</code> &amp; <code class="language-plaintext highlighter-rouge">node.prev()</code></h3>

<p>Returns the next/previous child of the parent node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">next</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">next</span> <span class="o">&amp;&amp;</span> <span class="nx">next</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">combinator</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Qualified IDs are not allowed!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nodereplacewithnode"><code class="language-plaintext highlighter-rouge">node.replaceWith(node)</code></h3>

<p>Replace a node with another.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">attr</span> <span class="o">=</span> <span class="nx">selectors</span><span class="p">.</span><span class="nx">first</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">className</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">className</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">});</span>
<span class="nx">attr</span><span class="p">.</span><span class="nx">replaceWith</span><span class="p">(</span><span class="nx">className</span><span class="p">);</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">node</code>: The node to substitute the original with.</li>
</ul>

<h3 id="noderemove"><code class="language-plaintext highlighter-rouge">node.remove()</code></h3>

<p>Removes the node from its parent node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">remove</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nodeclone"><code class="language-plaintext highlighter-rouge">node.clone()</code></h3>

<p>Returns a copy of a node, detached from any parent containers that the
original might have had.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">cloned</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">id</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">search</span><span class="dl">'</span><span class="p">});</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">cloned</span><span class="p">);</span>

<span class="c1">// =&gt; #search</span>
</code></pre></div></div>

<h3 id="nodeisatpositionline-column"><code class="language-plaintext highlighter-rouge">node.isAtPosition(line, column)</code></h3>

<p>Return a <code class="language-plaintext highlighter-rouge">boolean</code> indicating whether this node includes the character at the
position of the given line and column. Returns <code class="language-plaintext highlighter-rouge">undefined</code> if the nodes lack
sufficient source metadata to determine the position.</p>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">line</code>: 1-index based line number relative to the start of the selector.</li>
  <li><code class="language-plaintext highlighter-rouge">column</code>: 1-index based column number relative to the start of the selector.</li>
</ul>

<h3 id="nodespaces"><code class="language-plaintext highlighter-rouge">node.spaces</code></h3>

<p>Extra whitespaces around the node will be moved into <code class="language-plaintext highlighter-rouge">node.spaces.before</code> and
<code class="language-plaintext highlighter-rouge">node.spaces.after</code>. So for example, these spaces will be moved as they have
no semantic meaning:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nt">h1</span>     <span class="o">,</span>     <span class="nt">h2</span>   <span class="p">{}</span>
</code></pre></div></div>

<p>For descendent selectors, the value is always a single space.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">h1</span>        <span class="nt">h2</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Additional whitespace is found in either the <code class="language-plaintext highlighter-rouge">node.spaces.before</code> and <code class="language-plaintext highlighter-rouge">node.spaces.after</code> depending on the presence of comments or other whitespace characters. If the actual whitespace does not start or end with a single space, the node’s raw value is set to the actual space(s) found in the source.</p>

<h3 id="nodesource"><code class="language-plaintext highlighter-rouge">node.source</code></h3>

<p>An object describing the node’s start/end, line/column source position.</p>

<p>Within the following CSS, the <code class="language-plaintext highlighter-rouge">.bar</code> class node …</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.foo</span><span class="o">,</span>
  <span class="nc">.bar</span> <span class="p">{}</span>
</code></pre></div></div>

<p>… will contain the following <code class="language-plaintext highlighter-rouge">source</code> object.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">source</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">start</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">line</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="na">column</span><span class="p">:</span> <span class="mi">3</span>
    <span class="p">},</span>
    <span class="nx">end</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">line</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nx">column</span><span class="p">:</span> <span class="mi">6</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="nodesourceindex"><code class="language-plaintext highlighter-rouge">node.sourceIndex</code></h3>

<p>The zero-based index of the node within the original source string.</p>

<p>Within the following CSS, the <code class="language-plaintext highlighter-rouge">.baz</code> class node will have a <code class="language-plaintext highlighter-rouge">sourceIndex</code> of <code class="language-plaintext highlighter-rouge">12</code>.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">.foo</span><span class="o">,</span> <span class="nc">.bar</span><span class="o">,</span> <span class="nc">.baz</span> <span class="p">{}</span>
</code></pre></div></div>

<h2 id="container-types">Container types</h2>

<p>The <code class="language-plaintext highlighter-rouge">root</code>, <code class="language-plaintext highlighter-rouge">selector</code>, and <code class="language-plaintext highlighter-rouge">pseudo</code> nodes have some helper methods for working
with their children.</p>

<h3 id="containernodes"><code class="language-plaintext highlighter-rouge">container.nodes</code></h3>

<p>An array of the container’s children.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Input: h1 h2</span>
<span class="nx">selectors</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span>   <span class="c1">// =&gt; 3</span>
<span class="nx">selectors</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span> <span class="c1">// =&gt; 'h1'</span>
<span class="nx">selectors</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">value</span> <span class="c1">// =&gt; ' '</span>
</code></pre></div></div>

<h3 id="containerfirst--containerlast"><code class="language-plaintext highlighter-rouge">container.first</code> &amp; <code class="language-plaintext highlighter-rouge">container.last</code></h3>

<p>The first/last child of the container.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">first</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">last</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="containeratindex"><code class="language-plaintext highlighter-rouge">container.at(index)</code></h3>

<p>Returns the node at position <code class="language-plaintext highlighter-rouge">index</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">index</code>: The index of the node to return.</li>
</ul>

<h3 id="containeratpositionline-column"><code class="language-plaintext highlighter-rouge">container.atPosition(line, column)</code></h3>

<p>Returns the node at the source position <code class="language-plaintext highlighter-rouge">index</code>.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">first</span><span class="p">;</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">index</code>: The index of the node to return.</li>
</ul>

<h3 id="containerindexnode"><code class="language-plaintext highlighter-rouge">container.index(node)</code></h3>

<p>Return the index of the node within its container.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">index</span><span class="p">(</span><span class="nx">selector</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// =&gt; 2</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">node</code>: A node within the current container.</li>
</ul>

<h3 id="containerlength"><code class="language-plaintext highlighter-rouge">container.length</code></h3>

<p>Proxy to the length of the container’s nodes.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">container</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">container</span><span class="p">.</span><span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span>
</code></pre></div></div>

<h3 id="container-array-iterators"><code class="language-plaintext highlighter-rouge">container</code> Array iterators</h3>

<p>The container class provides proxies to certain Array methods; these are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">container.map === container.nodes.map</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.reduce === container.nodes.reduce</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.every === container.nodes.every</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.some === container.nodes.some</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.filter === container.nodes.filter</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.sort === container.nodes.sort</code></li>
</ul>

<p>Note that these methods only work on a container’s immediate children; recursive
iteration is provided by <code class="language-plaintext highlighter-rouge">container.walk</code>.</p>

<h3 id="containereachcallback"><code class="language-plaintext highlighter-rouge">container.each(callback)</code></h3>

<p>Iterate the container’s immediate children, calling <code class="language-plaintext highlighter-rouge">callback</code> for each child.
You may return <code class="language-plaintext highlighter-rouge">false</code> within the callback to break the iteration.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">className</span><span class="p">;</span>
<span class="nx">selectors</span><span class="p">.</span><span class="nx">each</span><span class="p">((</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">selector</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">class</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">className</span> <span class="o">=</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Note that unlike <code class="language-plaintext highlighter-rouge">Array#forEach()</code>, this iterator is safe to use whilst adding
or removing nodes from the container.</p>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">callback (function)</code>: A function to call for each node, which receives <code class="language-plaintext highlighter-rouge">node</code>
and <code class="language-plaintext highlighter-rouge">index</code> arguments.</li>
</ul>

<h3 id="containerwalkcallback"><code class="language-plaintext highlighter-rouge">container.walk(callback)</code></h3>

<p>Like <code class="language-plaintext highlighter-rouge">container#each</code>, but will also iterate child nodes as long as they are
<code class="language-plaintext highlighter-rouge">container</code> types.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selectors</span><span class="p">.</span><span class="nx">walk</span><span class="p">((</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// all nodes</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">callback (function)</code>: A function to call for each node, which receives <code class="language-plaintext highlighter-rouge">node</code>
and <code class="language-plaintext highlighter-rouge">index</code> arguments.</li>
</ul>

<p>This iterator is safe to use whilst mutating <code class="language-plaintext highlighter-rouge">container.nodes</code>,
like <code class="language-plaintext highlighter-rouge">container#each</code>.</p>

<h3 id="containerwalk-proxies"><code class="language-plaintext highlighter-rouge">container.walk</code> proxies</h3>

<p>The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">container.walkAttributes</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkClasses</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkCombinators</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkComments</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkIds</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkNesting</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkPseudos</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkTags</code></li>
  <li><code class="language-plaintext highlighter-rouge">container.walkUniversals</code></li>
</ul>

<h3 id="containersplitcallback"><code class="language-plaintext highlighter-rouge">container.split(callback)</code></h3>

<p>This method allows you to split a group of nodes by returning <code class="language-plaintext highlighter-rouge">true</code> from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (input) =&gt; h1 h2&gt;&gt;h3</span>
<span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">selectors</span><span class="p">.</span><span class="nx">first</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="nx">selector</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">selector</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">combinator</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// (node values) =&gt; [['h1', ' '], ['h2', '&gt;&gt;'], ['h3']]</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">callback (function)</code>: A function to call for each node, which receives <code class="language-plaintext highlighter-rouge">node</code>
as an argument.</li>
</ul>

<h3 id="containerprependnode--containerappendnode"><code class="language-plaintext highlighter-rouge">container.prepend(node)</code> &amp; <code class="language-plaintext highlighter-rouge">container.append(node)</code></h3>

<p>Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">id</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">search</span><span class="dl">'</span><span class="p">});</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">node</code>: The node to add.</li>
</ul>

<h3 id="containerinsertbeforeold-new--containerinsertafterold-new"><code class="language-plaintext highlighter-rouge">container.insertBefore(old, new)</code> &amp; <code class="language-plaintext highlighter-rouge">container.insertAfter(old, new)</code></h3>

<p>Add a node before or after an existing node in a container:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selectors</span><span class="p">.</span><span class="nx">walk</span><span class="p">(</span><span class="nx">selector</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">selector</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">class</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">className</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">className</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">theme-name</span><span class="dl">'</span><span class="p">});</span>
        <span class="nx">selector</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">insertAfter</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">className</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">old</code>: The existing node in the container.</li>
  <li><code class="language-plaintext highlighter-rouge">new</code>: The new node to add before/after the existing node.</li>
</ul>

<h3 id="containerremovechildnode"><code class="language-plaintext highlighter-rouge">container.removeChild(node)</code></h3>

<p>Remove the node from the container. Note that you can also use
<code class="language-plaintext highlighter-rouge">node.remove()</code> if you would like to remove just a single node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// =&gt; 2</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// =&gt; 1;</span>
<span class="nx">id</span><span class="p">.</span><span class="nx">parent</span>       <span class="c1">// undefined</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">node</code>: The node to remove.</li>
</ul>

<h3 id="containerremoveall-or-containerempty"><code class="language-plaintext highlighter-rouge">container.removeAll()</code> or <code class="language-plaintext highlighter-rouge">container.empty()</code></h3>

<p>Remove all children from the container.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">selector</span><span class="p">.</span><span class="nx">removeAll</span><span class="p">();</span>
<span class="nx">selector</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// =&gt; 0</span>
</code></pre></div></div>

<h2 id="root-nodes">Root nodes</h2>

<p>A root node represents a comma separated list of selectors. Indeed, all
a root’s <code class="language-plaintext highlighter-rouge">toString()</code> method does is join its selector children with a ‘,’.
Other than this, it has no special functionality and acts like a container.</p>

<h3 id="roottrailingcomma"><code class="language-plaintext highlighter-rouge">root.trailingComma</code></h3>

<p>This will be set to <code class="language-plaintext highlighter-rouge">true</code> if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.</p>

<h2 id="selector-nodes">Selector nodes</h2>

<p>A selector node represents a single complex selector. For example, this
selector string <code class="language-plaintext highlighter-rouge">h1 h2 h3, [href] &gt; p</code>, is represented as two selector nodes.
It has no special functionality of its own.</p>

<h2 id="pseudo-nodes">Pseudo nodes</h2>

<p>A pseudo selector extends a container node; if it has any parameters of its
own (such as <code class="language-plaintext highlighter-rouge">h1:not(h2, h3)</code>), they will be its children. Note that the pseudo
<code class="language-plaintext highlighter-rouge">value</code> will always contain the colons preceding the pseudo identifier. This
is so that both <code class="language-plaintext highlighter-rouge">:before</code> and <code class="language-plaintext highlighter-rouge">::before</code> are properly represented in the AST.</p>

<h2 id="attribute-nodes">Attribute nodes</h2>

<h3 id="attributequoted"><code class="language-plaintext highlighter-rouge">attribute.quoted</code></h3>

<p>Returns <code class="language-plaintext highlighter-rouge">true</code> if the attribute’s value is wrapped in quotation marks, false if it is not.
Remains <code class="language-plaintext highlighter-rouge">undefined</code> if there is no attribute value.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="nt">foo</span><span class="o">]</span> <span class="c">/* false */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="s2">'foo'</span><span class="o">]</span> <span class="c">/* true */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="s1">"foo"</span><span class="o">]</span> <span class="c">/* true */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">]</span> <span class="c">/* undefined */</span>
</code></pre></div></div>

<h3 id="attributequalifiedattribute"><code class="language-plaintext highlighter-rouge">attribute.qualifiedAttribute</code></h3>

<p>Returns the attribute name qualified with the namespace if one is given.</p>

<h3 id="attributeoffsetofpart"><code class="language-plaintext highlighter-rouge">attribute.offsetOf(part)</code></h3>

<p>Returns the offset of the attribute part specified relative to the
 start of the node of the output string. This is useful in raising
 error messages about a specific part of the attribute, especially
 in combination with <code class="language-plaintext highlighter-rouge">attribute.sourceIndex</code>.</p>

<p>Returns <code class="language-plaintext highlighter-rouge">-1</code> if the name is invalid or the value doesn’t exist in this
 attribute.</p>

<p>The legal values for <code class="language-plaintext highlighter-rouge">part</code> are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"ns"</code> - alias for “namespace”</li>
  <li><code class="language-plaintext highlighter-rouge">"namespace"</code> - the namespace if it exists.</li>
  <li><code class="language-plaintext highlighter-rouge">"attribute"</code> - the attribute name</li>
  <li><code class="language-plaintext highlighter-rouge">"attributeNS"</code> - the start of the attribute or its namespace</li>
  <li><code class="language-plaintext highlighter-rouge">"operator"</code> - the match operator of the attribute</li>
  <li><code class="language-plaintext highlighter-rouge">"value"</code> - The value (string or identifier)</li>
  <li><code class="language-plaintext highlighter-rouge">"insensitive"</code> - the case insensitivity flag</li>
</ul>

<h3 id="attributerawsunquoted"><code class="language-plaintext highlighter-rouge">attribute.raws.unquoted</code></h3>

<p>Returns the unquoted content of the attribute’s value.
Remains <code class="language-plaintext highlighter-rouge">undefined</code> if there is no attribute value.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="nt">foo</span><span class="o">]</span> <span class="c">/* foo */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="s2">'foo'</span><span class="o">]</span> <span class="c">/* foo */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">=</span><span class="s1">"foo"</span><span class="o">]</span> <span class="c">/* foo */</span>
<span class="o">[</span><span class="nt">href</span><span class="o">]</span> <span class="c">/* undefined */</span>
</code></pre></div></div>

<h3 id="attributespaces"><code class="language-plaintext highlighter-rouge">attribute.spaces</code></h3>

<p>Like <code class="language-plaintext highlighter-rouge">node.spaces</code> with the <code class="language-plaintext highlighter-rouge">before</code> and <code class="language-plaintext highlighter-rouge">after</code> values containing the spaces
around the element, the parts of the attribute can also have spaces before
and after them. The for each of <code class="language-plaintext highlighter-rouge">attribute</code>, <code class="language-plaintext highlighter-rouge">operator</code>, <code class="language-plaintext highlighter-rouge">value</code> and
<code class="language-plaintext highlighter-rouge">insensitive</code> there is corresponding property of the same nam in
<code class="language-plaintext highlighter-rouge">node.spaces</code> that has an optional <code class="language-plaintext highlighter-rouge">before</code> or <code class="language-plaintext highlighter-rouge">after</code> string containing only
whitespace.</p>

<p>Note that corresponding values in <code class="language-plaintext highlighter-rouge">attributes.raws.spaces</code> contain values
including any comments. If set, these values will override the
<code class="language-plaintext highlighter-rouge">attribute.spaces</code> value. Take care to remove them if changing
<code class="language-plaintext highlighter-rouge">attribute.spaces</code>.</p>

<h3 id="attributeraws"><code class="language-plaintext highlighter-rouge">attribute.raws</code></h3>

<p>The raws object stores comments and other information necessary to re-render
the node exactly as it was in the source.</p>

<p>If a comment is embedded within the identifiers for the <code class="language-plaintext highlighter-rouge">namespace</code>, <code class="language-plaintext highlighter-rouge">attribute</code>
or <code class="language-plaintext highlighter-rouge">value</code> then a property is placed in the raws for that value containing the full source of the propery including comments.</p>

<p>If a comment is embedded within the space between parts of the attribute
then the raw for that space is set accordingly.</p>

<p>Setting an attribute’s property <code class="language-plaintext highlighter-rouge">raws</code> value to be deleted.</p>

<p>For now, changing the spaces required also updating or removing any of the
raws values that override them.</p>

<p>Example: <code class="language-plaintext highlighter-rouge">[ /*before*/ href /* after-attr */ = /* after-operator */ te/*inside-value*/st/* wow */ /*omg*/i/*bbq*/ /*whodoesthis*/]</code> would parse as:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">attribute</span><span class="p">:</span> <span class="dl">"</span><span class="s2">href</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">operator</span><span class="p">:</span> <span class="dl">"</span><span class="s2">=</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">value</span><span class="p">:</span> <span class="dl">"</span><span class="s2">test</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">spaces</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">before</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
    <span class="nx">after</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
    <span class="nx">attribute</span><span class="p">:</span> <span class="p">{</span> <span class="nl">before</span><span class="p">:</span> <span class="dl">'</span><span class="s1">  </span><span class="dl">'</span><span class="p">,</span> <span class="nx">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1">  </span><span class="dl">'</span> <span class="p">},</span>
    <span class="nx">operator</span><span class="p">:</span> <span class="p">{</span> <span class="nl">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1">  </span><span class="dl">'</span> <span class="p">},</span>
    <span class="nx">value</span><span class="p">:</span> <span class="p">{</span> <span class="nl">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="p">},</span>
    <span class="nx">insensitive</span><span class="p">:</span> <span class="p">{</span> <span class="nl">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span> <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">raws</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">spaces</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">attribute</span><span class="p">:</span> <span class="p">{</span> <span class="na">before</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> /*before*/ </span><span class="dl">'</span><span class="p">,</span> <span class="na">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> /* after-attr */ </span><span class="dl">'</span> <span class="p">},</span>
      <span class="na">operator</span><span class="p">:</span> <span class="p">{</span> <span class="na">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> /* after-operator */ </span><span class="dl">'</span> <span class="p">},</span>
      <span class="na">value</span><span class="p">:</span> <span class="p">{</span> <span class="na">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/* wow */ /*omg*/</span><span class="dl">'</span> <span class="p">},</span>
      <span class="na">insensitive</span><span class="p">:</span> <span class="p">{</span> <span class="na">after</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/*bbq*/ /*whodoesthis*/</span><span class="dl">'</span> <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">unquoted</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">value</span><span class="p">:</span> <span class="dl">'</span><span class="s1">te/*inside-value*/st</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="processor"><code class="language-plaintext highlighter-rouge">Processor</code></h2>

<h3 id="processoroptions"><code class="language-plaintext highlighter-rouge">ProcessorOptions</code></h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lossless</code> - When <code class="language-plaintext highlighter-rouge">true</code>, whitespace is preserved. Defaults to <code class="language-plaintext highlighter-rouge">true</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">updateSelector</code> - When <code class="language-plaintext highlighter-rouge">true</code>, if any processor methods are passed a postcss
<code class="language-plaintext highlighter-rouge">Rule</code> node instead of a string, then that Rule’s selector is updated
with the results of the processing. Defaults to <code class="language-plaintext highlighter-rouge">true</code>.</li>
</ul>

<h3 id="processprocesssyncselectors-options"><code class="language-plaintext highlighter-rouge">process|processSync(selectors, [options])</code></h3>

<p>Processes the <code class="language-plaintext highlighter-rouge">selectors</code>, returning a string from the result of processing.</p>

<p>Note: when the <code class="language-plaintext highlighter-rouge">updateSelector</code> option is set, the rule’s selector
will be updated with the resulting string.</p>

<p><strong>Example:</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">postcss-selector-parser</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">processor</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">();</span>

<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">processSync</span><span class="p">(</span><span class="dl">'</span><span class="s1"> .class</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="c1">// =&gt;  .class</span>

<span class="c1">// Asynchronous operation</span>
<span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">process</span><span class="p">(</span><span class="dl">'</span><span class="s1"> .class</span><span class="dl">'</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
    <span class="c1">// =&gt; .class</span>
<span class="p">});</span>

<span class="c1">// To have the parser normalize whitespace values, utilize the options</span>
<span class="nx">result</span> <span class="o">=</span> <span class="nx">processor</span><span class="p">.</span><span class="nx">processSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">  .class  </span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="na">lossless</span><span class="p">:</span> <span class="kc">false</span><span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="c1">// =&gt; .class</span>

<span class="c1">// For better syntax errors, pass a PostCSS Rule node.</span>
<span class="kd">const</span> <span class="nx">postcss</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">postcss</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">rule</span> <span class="o">=</span> <span class="nx">postcss</span><span class="p">.</span><span class="nx">rule</span><span class="p">({</span><span class="na">selector</span><span class="p">:</span> <span class="dl">'</span><span class="s1"> #foo    &gt; a,  .class  </span><span class="dl">'</span><span class="p">});</span>
<span class="nx">processor</span><span class="p">.</span><span class="nx">process</span><span class="p">(</span><span class="nx">rule</span><span class="p">,</span> <span class="p">{</span><span class="na">lossless</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">updateSelector</span><span class="p">:</span> <span class="kc">true</span><span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="c1">// =&gt; #foo&gt;a,.class</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">rule:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">rule</span><span class="p">.</span><span class="nx">selector</span><span class="p">);</span>
    <span class="c1">// =&gt; rule: #foo&gt;a,.class</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">selectors (string|postcss.Rule)</code>: Either a selector string or a PostCSS Rule
node.</li>
  <li><code class="language-plaintext highlighter-rouge">[options] (object)</code>: Process options</li>
</ul>

<h3 id="astastsyncselectors-options"><code class="language-plaintext highlighter-rouge">ast|astSync(selectors, [options])</code></h3>

<p>Like <code class="language-plaintext highlighter-rouge">process()</code> and <code class="language-plaintext highlighter-rouge">processSync()</code> but after
processing the <code class="language-plaintext highlighter-rouge">selectors</code> these methods return the <code class="language-plaintext highlighter-rouge">Root</code> node of the result
instead of a string.</p>

<p>Note: when the <code class="language-plaintext highlighter-rouge">updateSelector</code> option is set, the rule’s selector
will be updated with the resulting string.</p>

<h3 id="transformtransformsyncselectors-options"><code class="language-plaintext highlighter-rouge">transform|transformSync(selectors, [options])</code></h3>

<p>Like <code class="language-plaintext highlighter-rouge">process()</code> and <code class="language-plaintext highlighter-rouge">processSync()</code> but after
processing the <code class="language-plaintext highlighter-rouge">selectors</code> these methods return the value returned by the
processor callback.</p>

<p>Note: when the <code class="language-plaintext highlighter-rouge">updateSelector</code> option is set, the rule’s selector
will be updated with the resulting string.</p>

<h3 id="error-handling-within-selector-processors">Error Handling Within Selector Processors</h3>

<p>The root node passed to the selector processor callback
has a method <code class="language-plaintext highlighter-rouge">error(message, options)</code> that returns an
error object. This method should always be used to raise
errors relating to the syntax of selectors. The options
to this method are passed to postcss’s error constructor
(<a href="http://api.postcss.org/Container.html#error">documentation</a>).</p>

<h4 id="async-error-example">Async Error Example</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">processor</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">walkClasses</span><span class="p">((</span><span class="nx">classNode</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="sr">/^</span><span class="se">(</span><span class="sr">.*</span><span class="se">)[</span><span class="sr">-_</span><span class="se">]</span><span class="sr">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">classNode</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">msg</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">classes may not have underscores or dashes in them</span><span class="dl">"</span><span class="p">;</span>
                <span class="nx">reject</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="p">{</span>
                    <span class="na">index</span><span class="p">:</span> <span class="nx">classNode</span><span class="p">.</span><span class="nx">sourceIndex</span> <span class="o">+</span> <span class="nb">RegExp</span><span class="p">.</span><span class="nx">$1</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="na">word</span><span class="p">:</span> <span class="nx">classNode</span><span class="p">.</span><span class="nx">value</span>
                <span class="p">}));</span>
            <span class="p">}</span>
        <span class="p">});</span>
        <span class="nx">resolve</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">postcss</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">postcss</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">postcss-selector-parser</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">selectorProcessor</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">processor</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">plugin</span> <span class="o">=</span> <span class="nx">postcss</span><span class="p">.</span><span class="nx">plugin</span><span class="p">(</span><span class="dl">'</span><span class="s1">classValidator</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">promises</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">walkRules</span><span class="p">(</span><span class="nx">rule</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">promises</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">selectorProcessor</span><span class="p">.</span><span class="nx">process</span><span class="p">(</span><span class="nx">rule</span><span class="p">));</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">promises</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">});</span>
<span class="nx">postcss</span><span class="p">(</span><span class="nx">plugin</span><span class="p">()).</span><span class="nx">process</span><span class="p">(</span><span class="s2">`
.foo-bar {
  color: red;
}
`</span><span class="p">.</span><span class="nx">trim</span><span class="p">(),</span> <span class="p">{</span><span class="na">from</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test.css</span><span class="dl">'</span><span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">()));</span>

<span class="c1">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="c1">//</span>
<span class="c1">// &gt; 1 | .foo-bar {</span>
<span class="c1">//     |     ^</span>
<span class="c1">//   2 |   color: red;</span>
<span class="c1">//   3 | }</span>
</code></pre></div></div>

<h4 id="synchronous-error-example">Synchronous Error Example</h4>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">processor</span> <span class="o">=</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">walkClasses</span><span class="p">((</span><span class="nx">classNode</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="sr">/.*</span><span class="se">[</span><span class="sr">-_</span><span class="se">]</span><span class="sr">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">classNode</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">msg</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">classes may not have underscores or dashes in them</span><span class="dl">"</span><span class="p">;</span>
            <span class="k">throw</span> <span class="nx">root</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">msg</span><span class="p">,</span> <span class="p">{</span>
                <span class="na">index</span><span class="p">:</span> <span class="nx">classNode</span><span class="p">.</span><span class="nx">sourceIndex</span><span class="p">,</span>
                <span class="na">word</span><span class="p">:</span> <span class="nx">classNode</span><span class="p">.</span><span class="nx">value</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">postcss</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">postcss</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">parser</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">postcss-selector-parser</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">selectorProcessor</span> <span class="o">=</span> <span class="nx">parser</span><span class="p">(</span><span class="nx">processor</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">plugin</span> <span class="o">=</span> <span class="nx">postcss</span><span class="p">.</span><span class="nx">plugin</span><span class="p">(</span><span class="dl">'</span><span class="s1">classValidator</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">walkRules</span><span class="p">(</span><span class="nx">rule</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">selectorProcessor</span><span class="p">.</span><span class="nx">processSync</span><span class="p">(</span><span class="nx">rule</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">};</span>
<span class="p">});</span>
<span class="nx">postcss</span><span class="p">(</span><span class="nx">plugin</span><span class="p">()).</span><span class="nx">process</span><span class="p">(</span><span class="s2">`
.foo-bar {
  color: red;
}
`</span><span class="p">.</span><span class="nx">trim</span><span class="p">(),</span> <span class="p">{</span><span class="na">from</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test.css</span><span class="dl">'</span><span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">toString</span><span class="p">()));</span>

<span class="c1">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="c1">//</span>
<span class="c1">// &gt; 1 | .foo-bar {</span>
<span class="c1">//     |     ^</span>
<span class="c1">//   2 |   color: red;</span>
<span class="c1">//   3 | }</span>
</code></pre></div></div>

  </body>
</html>
