<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Acorn AST walker</title>
    <link rel="stylesheet" media="all" href="/assets/css/main.css"/>
  </head>
  <body class="bg-blue-900 p-8">
    <h1 id="acorn-ast-walker">Acorn AST walker</h1>

<p>An abstract syntax tree walker for the
<a href="https://github.com/estree/estree">ESTree</a> format.</p>

<h2 id="community">Community</h2>

<p>Acorn is open source software released under an
<a href="https://github.com/acornjs/acorn/blob/master/acorn-walk/LICENSE">MIT license</a>.</p>

<p>You are welcome to
<a href="https://github.com/acornjs/acorn/issues">report bugs</a> or create pull
requests on <a href="https://github.com/acornjs/acorn">github</a>. For questions
and discussion, please use the
<a href="https://discuss.ternjs.net">Tern discussion forum</a>.</p>

<h2 id="installation">Installation</h2>

<p>The easiest way to install acorn is from <a href="https://www.npmjs.com/"><code class="language-plaintext highlighter-rouge">npm</code></a>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>acorn-walk
</code></pre></div></div>

<p>Alternately, you can download the source and build acorn yourself:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/acornjs/acorn.git
<span class="nb">cd </span>acorn
npm <span class="nb">install</span>
</code></pre></div></div>

<h2 id="interface">Interface</h2>

<p>An algorithm for recursing through a syntax tree is stored as an
object, with a property for each tree node type holding a function
that will recurse through such a node. There are several ways to run
such a walker.</p>

<p><strong>simple</strong><code class="language-plaintext highlighter-rouge">(node, visitors, base, state)</code> does a ‘simple’ walk over a
tree. <code class="language-plaintext highlighter-rouge">node</code> should be the AST node to walk, and <code class="language-plaintext highlighter-rouge">visitors</code> an object
with properties whose names correspond to node types in the <a href="https://github.com/estree/estree">ESTree
spec</a>. The properties should contain
functions that will be called with the node object and, if applicable
the state at that point. The last two arguments are optional. <code class="language-plaintext highlighter-rouge">base</code>
is a walker algorithm, and <code class="language-plaintext highlighter-rouge">state</code> is a start state. The default
walker will simply visit all statements and expressions and not
produce a meaningful state. (An example of a use of state is to track
scope at each point in the tree.)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">acorn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn</span><span class="dl">"</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">walk</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn-walk</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">walk</span><span class="p">.</span><span class="nx">simple</span><span class="p">(</span><span class="nx">acorn</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">"</span><span class="s2">let x = 10</span><span class="dl">"</span><span class="p">),</span> <span class="p">{</span>
  <span class="nx">Literal</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Found a literal: </span><span class="p">${</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p><strong>ancestor</strong><code class="language-plaintext highlighter-rouge">(node, visitors, base, state)</code> does a ‘simple’ walk over
a tree, building up an array of ancestor nodes (including the current node)
and passing the array to the callbacks as a third parameter.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">acorn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn</span><span class="dl">"</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">walk</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn-walk</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">walk</span><span class="p">.</span><span class="nx">ancestor</span><span class="p">(</span><span class="nx">acorn</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo('hi')</span><span class="dl">"</span><span class="p">),</span> <span class="p">{</span>
  <span class="nx">Literal</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">ancestors</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">This literal's ancestors are:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">ancestors</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p><strong>recursive</strong><code class="language-plaintext highlighter-rouge">(node, state, functions, base)</code> does a ‘recursive’
walk, where the walker functions are responsible for continuing the
walk on the child nodes of their target node. <code class="language-plaintext highlighter-rouge">state</code> is the start
state, and <code class="language-plaintext highlighter-rouge">functions</code> should contain an object that maps node types
to walker functions. Such functions are called with <code class="language-plaintext highlighter-rouge">(node, state, c)</code>
arguments, and can cause the walk to continue on a sub-node by calling
the <code class="language-plaintext highlighter-rouge">c</code> argument on it with <code class="language-plaintext highlighter-rouge">(node, state)</code> arguments. The optional
<code class="language-plaintext highlighter-rouge">base</code> argument provides the fallback walker functions for node types
that aren’t handled in the <code class="language-plaintext highlighter-rouge">functions</code> object. If not given, the
default walkers will be used.</p>

<p><strong>make</strong><code class="language-plaintext highlighter-rouge">(functions, base)</code> builds a new walker object by using the
walker functions in <code class="language-plaintext highlighter-rouge">functions</code> and filling in the missing ones by
taking defaults from <code class="language-plaintext highlighter-rouge">base</code>.</p>

<p><strong>full</strong><code class="language-plaintext highlighter-rouge">(node, callback, base, state)</code> does a ‘full’ walk over a
tree, calling the callback with the arguments (node, state, type) for
each node</p>

<p><strong>fullAncestor</strong><code class="language-plaintext highlighter-rouge">(node, callback, base, state)</code> does a ‘full’ walk
over a tree, building up an array of ancestor nodes (including the
current node) and passing the array to the callbacks as a third
parameter.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">acorn</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn</span><span class="dl">"</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">walk</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">acorn-walk</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">walk</span><span class="p">.</span><span class="nx">full</span><span class="p">(</span><span class="nx">acorn</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">"</span><span class="s2">1 + 1</span><span class="dl">"</span><span class="p">),</span> <span class="nx">node</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`There's a </span><span class="p">${</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">}</span><span class="s2"> node at </span><span class="p">${</span><span class="nx">node</span><span class="p">.</span><span class="nx">ch</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p><strong>findNodeAt</strong><code class="language-plaintext highlighter-rouge">(node, start, end, test, base, state)</code> tries to locate
a node in a tree at the given start and/or end offsets, which
satisfies the predicate <code class="language-plaintext highlighter-rouge">test</code>. <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> can be either <code class="language-plaintext highlighter-rouge">null</code>
(as wildcard) or a number. <code class="language-plaintext highlighter-rouge">test</code> may be a string (indicating a node
type) or a function that takes <code class="language-plaintext highlighter-rouge">(nodeType, node)</code> arguments and
returns a boolean indicating whether this node is interesting. <code class="language-plaintext highlighter-rouge">base</code>
and <code class="language-plaintext highlighter-rouge">state</code> are optional, and can be used to specify a custom walker.
Nodes are tested from inner to outer, so if two nodes match the
boundaries, the inner one will be preferred.</p>

<p><strong>findNodeAround</strong><code class="language-plaintext highlighter-rouge">(node, pos, test, base, state)</code> is a lot like
<code class="language-plaintext highlighter-rouge">findNodeAt</code>, but will match any node that exists ‘around’ (spanning)
the given position.</p>

<p><strong>findNodeAfter</strong><code class="language-plaintext highlighter-rouge">(node, pos, test, base, state)</code> is similar to
<code class="language-plaintext highlighter-rouge">findNodeAround</code>, but will match all nodes <em>after</em> the given position
(testing outer nodes before inner nodes).</p>

  </body>
</html>
